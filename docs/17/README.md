# 流水线处理器
通过icache提升了NPC的指令供给能力, 虽然面积预算很有限, 但添加icache还是明显提升了NPC的总体性能表现. 剩下的优化方向包括提升数据供给能力和提升计算效率.

## 评估dcache的理想收益 & 通过cachesim评估dcache的预期性能表现
应该会发现, 在剩余的面积预算下, 我们很难通过dcache来有效提升NPC的数据供给能力. 因此, 把剩余的面积用在提升计算效率, 是更科学的决策. 目前的NPC是多周期的, 这意味着NPC每经过若干个周期才能执行一条指令. 如果能提升NPC执行指令的吞吐, 就可以提升其计算效率. 流水线作为一种指令级并行技术, 可以有效提升NPC执行指令的吞吐

## 评估提升计算效率的理想收益
根据性能计数器可以来估算流水线技术的理想收益: 假设除访存指令之外, NPC每个周期都可以执行一条指令, 尝试估算在当前icache缺失情况的条件下, 此时NPC的理想加速比能到多少?

## 流水线的基本原理
指令流水线: 处理器用流水线方式来执行指令, 把指令执行的过程分为若干个阶段, 让每个部件处理其中一个阶段, 并让这些部件保持工作状态, 可以连续处理不同指令的同一个阶段, 使得从总体上来看, 每个周期都有一条指令完成执行, 从而提升处理器的吞吐. 我们可以对几种处理器的性能进行简单的分析评估. 假设将处理器的工作分为取指, 译码, 执行, 访存, 写回这5个阶段, 它们的逻辑延迟都是1ns, 且先不考虑取指和访存的延迟.

- 单周期处理器: 阶段间无寄存器, 因此关键路径为5ns, 频率为200MHz. 其中, 一条指令需要执行1周期, 即5ns; 每1周期执行1条指令, 即`IPC = 1`
- 多周期处理器: 阶段间有寄存器, 因此关键路径为1ns, 频率为1000MHz. 其中, 一条指令需要执行5周期, 即5ns; 每5周期执行1条指令, 即`IPC = 0.2`
- 流水线处理器: 阶段间有寄存器, 因此关键路径为1ns, 频率为1000MHz. 其中, 一条指令需要执行5周期, 即5ns; 每1周期执行1条指令, 即`IPC = 1`

虽然指令执行的延迟仍然是5ns, 但流水线具有频率高和IPC高的优势, 这些优势本质上是由指令级并行技术带来的: 流水线处理器的每个周期都在处理5条不同的指令. 当然, 上面只是从理想情况下分析得到的数据. 如果考虑SoC中的访存, IPC就远远没有这么高了; 此外流水线处理器也并不是总能在每个周期都执行5条指令

#### 更长的流水线
上面的例子只将流水线划分成5个阶段. 事实上, 我们可以将流水线划分成更多的阶段, 使得每一个阶段的逻辑更简单, 从而提升处理器整体的频率. 这种流水线称为"超流水"(superpipeline). 例如, 如果能将流水线划分成30级, 按照上面的估算, 理论上频率可以达到6GHz. 但目前的主流高性能处理器一般只会将流水线划分成15级左右, 导致不宜将流水线划分成过多的阶段的因素有(from chatgpt):

- 复杂的控制逻辑： 随着流水线阶段的增加，控制逻辑会变得更加复杂。需要更多的控制信号来协调各个阶段，避免数据冒险、控制冒险等问题。这不仅增加了硬件设计的难度，也可能导致更多的时钟周期浪费
- 数据冒险和转发开销： 多个流水线阶段可能增加了数据冒险的可能性，需要更多的转发机制或前递路径来解决。这些额外的开销可能抵消通过超流水线带来的性能提升。
- 分支预测的困难： 更长的流水线意味着分支预测的正确性变得更加重要，但由于分支可能在流水线的较长阶段内才被识别到，因此分支预测失误的代价会更高。更长的流水线可能导致较大的性能惩罚。
- 处理器的设计和制造成本： 超流水线不仅增加了设计复杂度，也可能增加制造成本。每增加一个阶段，可能都需要更多的管脚、逻辑单元、寄存器等资源，这会增加芯片的面积和功耗

## 流水线的简单实现
首先对 xcore 进行重构, 使得更容易修改成流水线结构:
- 实现一个流水线寄存器模块 `pipe_regs` 代替所有的流水线寄存器模块, 实际上是一个 entry 为 2 的 fifo, 并添加 flush 功能
- 添加 id 与 ex, ex 与 lsu 之间的流水线寄存器
- 把 csr 的写入修改到执行 (ex) 阶段
