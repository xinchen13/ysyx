# 用RTL实现最简单的处理器(NPC)
通过RTL代码来实现一个最简单的处理器

## 最简单的处理器组成
TRM的各个部件:
- PC: 不断加1(指令长度为1)的计数器
- 寄存器: 通用寄存器(general purpose register), 由一组寄存器组成
- 加法器
- 存储器

可以按照处理器工作流程给项目划分模块:
- IFU(Instruction Fetch Unit): 负责根据当前PC从存储器中取出一条指令
- IDU(Instruction Decode Unit): 负责对当前指令进行译码，准备执行阶段使用的数据和控制信号
- EXU(Excution Unit): 负责根据控制信号对数据进行执行操作, 并将执行结果写回寄存器或存储器
- 更新PC: 通过RTL实现时, 这一操作一般与PC寄存器一同实现, 因而无需为此划分一个独立的模块

特别的，对于存储器, 为了方便测试, 我们不通过RTL来实现这个存储器, 而是用C++来实现它. 于是, 我们需要将存储器访问接口的信号拉到顶层, 通过C++代码来访问存储器:

```cpp
while (???) {
  ...
  top->inst = pmem_read(top->pc);
  top->eval();
  ...
}
```

## 在npc中实现第一条指令
### 画出仅支持addi指令的单周期处理器的架构图，如下所示

<img src="../../figs/CamScanner 08-12-2024 14.50.jpg" width="580" />

### 在npc中实现addi指令
- alu 只实现了加法
- regfile 使用一个读端口，一个写端口
- PC的复位值设置为`0x80000000`
- 存储器中可以放置若干条addi指令的二进制编码(可以利用0号寄存器的特性来编写行为确定的指令)
- 由于目前未实现跳转指令, 因此NPC只能顺序执行, 可以在NPC执行若干指令之后停止仿真，利用dpi-c机制和ebreak实现
- 可以通过查看波形, 或者在RTL代码中打印通用寄存器的状态, 来检查addi指令是否被正确执行
- 使用NVBoard需要RTL代码比较好地支持设备, 目前不接入NVBoard

## 让程序决定仿真何时结束
### 通过DPI-C实现ebreak
DPI-C: RTL代码和C++代码之间的交互机制

一开始仿真环境(C++代码)来决定执行多少条指令后结束仿真; 在RTL代码中利用DPI-C机制, 使得在NPC执行`ebreak`指令的时候通知仿真环境结束仿真. 实现后, 在存储器中放置一条`ebreak`指令来进行测试, 仿真环境只需要不停地进行仿真, 直到程序执行ebreak指令为止

- 利用DPI-C机制，在顶层模块中设置一个标识位，设置一个function供C++调用，从而利用这个标识位来进行循环判断，实现仿真的控制
- 此时的npc实现见分支 npc-addi 中的 $NPC_HOME
- 运行仿真，Makefile设置输出波形，之后查看对应寄存器，发现与预期的值相符，在npc中实现了addi指令