# 总线
目前已经设计了单周期处理器NPC, 也了解了设备如何工作. 不过之前是让仿真环境来提供设备的功能, 现在需要从硬件上实现NPC与其他设备通信的功能

计算机中每个模块并非独立工作, 不同的模块之间需要进行数据交换: CPU和内存控制器之间, 内存控制器和内存颗粒之间, 取指单元和译码单元之间等等,都需要通过一套约定的协议进行通信. 软件同样如此, 在我们使用的DiffTest中, NEMU需要与Spike通信, NPC也需要与NEMU通信才能实现相应的功能

从广义上来说, 总线其实就是一个通信系统, 用来在不同的模块之间进行数据传输. 狭义的总线即硬件模块间的通信协议

## 常见的总线模型
一般称主动发起通信的模块为master(主设备), 称响应通信的模块为slave(从设备)

### 最简单的总线(例如单周期处理器的IFU与IDU之间的通信)
- 每个周期master都向slave发送有效信息
- master一旦发送有效信息, slave能够立刻收到

### 异步总线
- 只有在valid信号有效时才认为信息有效
- master发送的信息, 只有在ready信号有效时才认为slave收到

valid和ready均有效, 也称为"握手", 表示master和slave对信息的成功传递达成共识

#### 状态机描述异步总线

```
 +-+ valid = 0
   | v         valid = 1
1. idle ----------------> 2. wait_ready <-+
   ^                          |      |    | ready = 0
   +--------------------------+      +----+
              ready = 1
```

一开始处于空闲状态idle, 将valid置为无效
- 如果不需要发送消息, 则一直处于idle状态
- 如果需要发送消息, 则将valid置为有效, 并进入wait_ready状态, 等待slave就绪
在wait_ready状态中, 同时检测slave的ready信号
- 如果ready信号有效, 则握手成功, 返回idle状态
- 如果ready信号无效, 则继续处于wait_ready状态等待

## 总线视角下的处理器设计
- 对于单周期处理器, 相当于每个周期上游发送的消息都有效, 同时下游处于就绪状态来接收新消息
- 对于多周期处理器, 上游模块空闲时消息无效, 下游模块忙碌时不接收新消息; IFU收到WBU的完成信号后再取下一条指令
- 对于流水线处理器, 则可以让IFU一直取指, 同时每个模块只要有消息处理完成, 就在每个周期都尝试向下游发送消息
- 对于乱序执行处理器, 则可以看成在流水线的基础上进行很小的扩展: 每一个下游模块中都有一个队列, 上游模块只需把消息发送到队列中, 就可以不用关心下游队列的状态继续工作

采取分布式的控制策略:
- 模块可以独立工作: 每个模块的行为只取决于自身和下游模块的状态(例如在乱序执行处理器中, 上游模块可以一直工作, 直到下游模块中的队列满为止)
- 具有更好的可扩展性: 在分布式控制中, 能够非常容易插入一个新模块, 只需要修改该模块的上下游模块的接口实现即可
- 采用这种基于握手的分布式控制, 可以统一不同微结构的处理器的设计. 乱序执行处理器天生就是分布式控制的, 这是因为乱序执行处理器中的模块和每个模块的状态都非常多, 且随时可能到来一些不同的事件(如中断到来, 流水线阻塞等), 如果采用集中式控制, 几乎无法保证控制器能在每个模块发生不同事件时都做出正确的决策

## 系统总线
连接处理器和存储器以及设备之间的总线通常称为系统总线

### 访问只读存储器
NPC仿真环境提供的`dpic_pmem_read()`没有读延迟, 收到读请求的当前周期就可以返回读数据, 但它只是用于方便我们实现单周期处理器, 实际上并不存在这样的存储器器件

假设存储器包含N个字, 每个字为32位. 同时假设该存储器的读延迟固定为1周期, 这实际上是一种同步存储器, 即从收到读请求到返回数据之间的延迟是固定的, SRAM的访问特性正是如此. 

如果不考虑写操作, 我们只需要一个只读存储器(ROM, Read-Only Memory)即可. 为了从ROM中读出数据, 相应的总线只需要两个信号, 分别为地址和数据, 二者的位宽分别为log2(N)和32. 其通信协议为:

- master(CPU)向slave(MEM)发送读地址raddr
- 下个周期slave向master回复数据rdata
- 上述行为每周期都发生

### 评估单周期NPC的主频和程序性能
#### 先运行microbench的train规模测试, 记录其运行结束所需的周期数
- 共运行了195139815条指令, 由于是单周期cpu, 即为周期数

#### 例化处理器
- 在RTL中注释通过DPI-C调用`dpic_pmem_read()`和`dpic_pmem_write()`的代码
- 为取指和访存各自实例化一个存储器. 为了保持单周期的特性, 实例化的存储器需要当前周期就能返回读数据, 因此我们可以像寄存器堆那样通过触发器实现它. 为了统一测试结果, 约定实例化的存储器大小为256x32b, 即1KB, 共实例化两个这样的存储器, 总大小为2K
- 单周期NPC要求每个周期都完成一条指令完整的生命周期, 因此无法连接任何现实中的存储器, 只能连带两个类似寄存器堆的存储器一同评估主频

#### 综合
- 用于综合的源文件见 [npc](./npc/), 为了顺利综合, 把写入寄存器的值引出作为输出
- 命令: `make sta DESIGN=xcore SDC_FILE=npc/gcd.sdc RTL_FILES="./npc/defines.svh ./npc/alu.sv ./npc/csr_regs.sv ./npc/exu.sv ./npc/idu.sv ./npc/mem.sv ./npc/pc_reg.sv ./npc/ram.sv ./npc/regfile.sv ./npc/rom.sv ./npc/wb.sv ./npc/xcore.sv" CLK_FREQ_MHZ=50`
- 综合出的面积是106971.634, 主频为382.639MHz

#### 估算结果并不准确, 可以说是非常乐观的
- 这个单周期NPC距离可流片的配置还差很远, 例如修改存储器的时候把I/O相关的部分都忽略了
- 上述主频是综合后的主频, 布局布线之后引入的线延迟会进一步把主频拉低
- 取指单元对应的存储器因为没有写操作, 被yosys优化掉了
- 访存单元对应的存储器其实也远远装不下microbench. 要成功把train规模的测试运行起来, 数据需要占用1MB内存. 这个大小都已经远远超过实际处理器芯片设计中可以容纳的触发器数量了, 先不考虑EDA工具的处理时间, 光是在芯片上摆满这么多触发器, 从占用面积来估算线延迟就已经巨大了

### 将IFU访问的存储器改造成SRAM (2周期处理器)
用RTL为IFU编写一个SRAM模块, 地址位宽为32bit, 数据位宽为32bit. 收到读请求后, SRAM模块通过DPI-C调用`dpic_pmem_read()`读出数据, 并延迟1周期返回读出的数据, 来实现一个更真实的存储器. 由于这个SRAM需要经过1周期才能拿到读出的数据, 这时候NPC已经不是一个严格意义上的单周期处理器了, 而是一个简单的多周期处理器:
- 在第1个周期, IFU发出取指请求
- 在第2个周期, IFU拿到指令, 并交给后续的模块译码并执行

具体实现上，加了一级取指与译码间的流水

#### 握手实现: 
- 对于流水线寄存器:
    - 使用带 enable 的 dff
    - valid 信号的传递: 当下级的 ready 有效时就将本级的 valid 打拍传递给下一级
    - 数据的传递: 当下级的 ready 有效且本级的 valid 有效时打拍传递给下一级
- 对于寄存器间的逻辑:
    - 每一级维护自己的 valid (区别于上级流水线传递的 valid), ready 以及指示本级计算已经结束的 done
    - 对于纯组合逻辑, done 始终为 1; 多周期逻辑在计算完成后置位
    - 本级输出ready = !本级输入valid || (本级done && 下级输入ready);
    - 本级输出valid = 本级输入valid & 本级done
- 其他说明:
    - 如果只给 valid 打拍而 ready 采用纯组合逻辑, 那么一方面逻辑路径长了之后会造成时序紧张, 另一方面会形成组合逻辑环路
    - 因此采用 skid buffer 来实现流水线寄存器, 给 valid, ready 和数据都打了一拍

#### 让DiffTest适配多周期处理器
修改成多周期处理器后, NPC就并非每个周期都执行一条指令了. 为了让DiffTest机制可以正确工作:

- 把 difftest 对比的pc寄存器调整为取指时的pc
- 当一条指令的生命周期结束(进入id阶段, 计算出dnpc)时才进行 difftest

### 访问可读可写存储器