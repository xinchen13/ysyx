# 总线
目前已经设计了单周期处理器NPC, 也了解了设备如何工作. 不过之前是让仿真环境来提供设备的功能, 现在需要从硬件上实现NPC与其他设备通信的功能

计算机中每个模块并非独立工作, 不同的模块之间需要进行数据交换: CPU和内存控制器之间, 内存控制器和内存颗粒之间, 取指单元和译码单元之间等等,都需要通过一套约定的协议进行通信. 软件同样如此, 在我们使用的DiffTest中, NEMU需要与Spike通信, NPC也需要与NEMU通信才能实现相应的功能

从广义上来说, 总线其实就是一个通信系统, 用来在不同的模块之间进行数据传输. 狭义的总线即硬件模块间的通信协议

## 常见的总线模型
一般称主动发起通信的模块为master(主设备), 称响应通信的模块为slave(从设备)

### 最简单的总线(例如单周期处理器的IFU与IDU之间的通信)
- 每个周期master都向slave发送有效信息
- master一旦发送有效信息, slave能够立刻收到

### 异步总线
- 只有在valid信号有效时才认为信息有效
- master发送的信息, 只有在ready信号有效时才认为slave收到

valid和ready均有效, 也称为"握手", 表示master和slave对信息的成功传递达成共识

#### 状态机描述异步总线

```
 +-+ valid = 0
   | v         valid = 1
1. idle ----------------> 2. wait_ready <-+
   ^                          |      |    | ready = 0
   +--------------------------+      +----+
              ready = 1
```

一开始处于空闲状态idle, 将valid置为无效
- 如果不需要发送消息, 则一直处于idle状态
- 如果需要发送消息, 则将valid置为有效, 并进入wait_ready状态, 等待slave就绪
在wait_ready状态中, 同时检测slave的ready信号
- 如果ready信号有效, 则握手成功, 返回idle状态
- 如果ready信号无效, 则继续处于wait_ready状态等待

## 总线视角下的处理器设计
- 对于单周期处理器, 相当于每个周期上游发送的消息都有效, 同时下游处于就绪状态来接收新消息
- 对于多周期处理器, 上游模块空闲时消息无效, 下游模块忙碌时不接收新消息; IFU收到WBU的完成信号后再取下一条指令
- 对于流水线处理器, 则可以让IFU一直取指, 同时每个模块只要有消息处理完成, 就在每个周期都尝试向下游发送消息
- 对于乱序执行处理器, 则可以看成在流水线的基础上进行很小的扩展: 每一个下游模块中都有一个队列, 上游模块只需把消息发送到队列中, 就可以不用关心下游队列的状态继续工作

采取分布式的控制策略:
- 模块可以独立工作: 每个模块的行为只取决于自身和下游模块的状态(例如在乱序执行处理器中, 上游模块可以一直工作, 直到下游模块中的队列满为止)
- 具有更好的可扩展性: 在分布式控制中, 能够非常容易插入一个新模块, 只需要修改该模块的上下游模块的接口实现即可
- 采用这种基于握手的分布式控制, 可以统一不同微结构的处理器的设计. 乱序执行处理器天生就是分布式控制的, 这是因为乱序执行处理器中的模块和每个模块的状态都非常多, 且随时可能到来一些不同的事件(如中断到来, 流水线阻塞等), 如果采用集中式控制, 几乎无法保证控制器能在每个模块发生不同事件时都做出正确的决策

## 系统总线
连接处理器和存储器以及设备之间的总线通常称为系统总线

### 访问只读存储器
NPC仿真环境提供的`dpic_pmem_read()`没有读延迟, 收到读请求的当前周期就可以返回读数据, 但它只是用于方便我们实现单周期处理器, 实际上并不存在这样的存储器器件

假设存储器包含N个字, 每个字为32位. 同时假设该存储器的读延迟固定为1周期, 这实际上是一种同步存储器, 即从收到读请求到返回数据之间的延迟是固定的, SRAM的访问特性正是如此. 

如果不考虑写操作, 我们只需要一个只读存储器(ROM, Read-Only Memory)即可. 为了从ROM中读出数据, 相应的总线只需要两个信号, 分别为地址和数据, 二者的位宽分别为log2(N)和32. 其通信协议为:

- master(CPU)向slave(MEM)发送读地址raddr
- 下个周期slave向master回复数据rdata
- 上述行为每周期都发生

#### 评估单周期NPC的主频和程序性能
先运行microbench的train规模测试, 记录其运行结束所需的周期数
- 共运行了195139815条指令, 由于是单周期cpu, 即为周期数

例化处理器
- 在RTL中注释通过DPI-C调用`dpic_pmem_read()`和`dpic_pmem_write()`的代码
- 为取指和访存各自实例化一个存储器. 为了保持单周期的特性, 实例化的存储器需要当前周期就能返回读数据, 因此我们可以像寄存器堆那样通过触发器实现它. 为了统一测试结果, 约定实例化的存储器大小为256x32b, 即1KB, 共实例化两个这样的存储器, 总大小为2K
- 单周期NPC要求每个周期都完成一条指令完整的生命周期, 因此无法连接任何现实中的存储器, 只能连带两个类似寄存器堆的存储器一同评估主频

综合
- 用于综合的源文件见 [sc-npc](./sc-npc/), 为了顺利综合, 把写入寄存器的值引出作为输出
- 命令: `make sta DESIGN=xcore SDC_FILE=sc-npc/gcd.sdc RTL_FILES="./sc-npc/defines.svh ./sc-npc/alu.sv ./sc-npc/csr_regs.sv ./sc-npc/exu.sv ./sc-npc/idu.sv ./sc-npc/mem.sv ./sc-npc/pc_reg.sv ./sc-npc/ram.sv ./sc-npc/regfile.sv ./sc-npc/rom.sv ./sc-npc/wb.sv ./sc-npc/xcore.sv" CLK_FREQ_MHZ=50`
- 综合出的面积是106971.634, 主频为382.639MHz

估算结果并不准确, 可以说是非常乐观的
- 这个单周期NPC距离可流片的配置还差很远, 例如修改存储器的时候把I/O相关的部分都忽略了
- 上述主频是综合后的主频, 布局布线之后引入的线延迟会进一步把主频拉低
- 取指单元对应的存储器因为没有写操作, 被yosys优化掉了
- 访存单元对应的存储器其实也远远装不下microbench. 要成功把train规模的测试运行起来, 数据需要占用1MB内存. 这个大小都已经远远超过实际处理器芯片设计中可以容纳的触发器数量了, 先不考虑EDA工具的处理时间, 光是在芯片上摆满这么多触发器, 从占用面积来估算线延迟就已经巨大了

#### 将IFU访问的存储器改造成SRAM (2周期处理器)
用RTL为IFU编写一个SRAM模块, 地址位宽为32bit, 数据位宽为32bit. 收到读请求后, SRAM模块通过DPI-C调用`dpic_pmem_read()`读出数据, 并延迟1周期返回读出的数据, 来实现一个更真实的存储器. 由于这个SRAM需要经过1周期才能拿到读出的数据, 这时候NPC已经不是一个严格意义上的单周期处理器了, 而是一个简单的多周期处理器:
- 在第1个周期, IFU发出取指请求
- 在第2个周期, IFU拿到指令, 并交给后续的模块译码并执行

具体实现上:
- 加了一级取指与译码间的流水
- 见 tag: 2-cycle-npc

#### 握手实现: 
- 对于流水线寄存器:
    - 使用带 enable 的 dff
    - valid 信号的传递: 当下级的 ready 有效时就将本级的 valid 打拍传递给下一级
    - 数据的传递: 当下级的 ready 有效且本级的 valid 有效时打拍传递给下一级
- 对于寄存器间的逻辑:
    - 每一级维护自己的 valid (区别于上级流水线传递的 valid), ready 以及指示本级计算已经结束的 done
    - 对于纯组合逻辑, done 始终为 1; 多周期逻辑在计算完成后置位
    - 本级输出ready = !本级输入valid || (本级done && 下级输入ready);
    - 本级输出valid = 本级输入valid & 本级done
- 其他说明:
    - 如果只给 valid 打拍而 ready 采用纯组合逻辑, 那么一方面逻辑路径长了之后会造成时序紧张, 另一方面会形成组合逻辑环路
    - 因此采用 skid buffer 来实现流水线寄存器, 给 valid, ready 和数据都打了一拍

#### 让DiffTest适配多周期处理器
修改成多周期处理器后, NPC就并非每个周期都执行一条指令了. 为了让DiffTest机制可以正确工作:

- 把 difftest 对比的pc寄存器调整为取指时的pc
- 当一条指令的生命周期结束(进入id阶段, 计算出dnpc)时才进行 difftest

### 访问可读可写存储器
如果要支持写操作, 就需要给cpu引出新的信号:

- 写地址waddr和写数据wdata
- 由于写操作并非每个周期都发生, 需要写使能信号wen
- 虽然读操作也并非每个周期都发生, 例如对于改成多周期处理器的NPC, 第2个周期并不需要取指, 但由于读操作不会改变电路状态, 因此理论上读使能并非必须. 不过实际中一般还是有读使能ren, 如果没有读请求, 存储器就无需进行读操作, 从而节省能耗
- 写操作可能只写入一个字当中的若干字节(例如sb指令只写入1字节), 因此还需要添加写掩码信号wmask, 用于指定写入数据中的哪些字节

```
+-----+ raddr[log2(N)-1:0] ---> +-----+
|     | ren                ---> |     |
|     | <---        rdata[31:0] |     |
|     | waddr[log2(N)-1:0] ---> |     |
| CPU | wdata[31:0]        ---> | MEM |
|     | wen                ---> |     |
|     | wmask[3:0]         ---> |     |
+-----+                         +-----+
```

同时, 通信协议需要增加写操作行为的定义:

```c
if (wen) {
  // wmask_full为wmask按比特展开的结果
  M[waddr] = (wdata & wmask_full) | M[waddr] & ~wmask_full;
}
```

#### 将LSU(访存单元)访问的存储器改造成SRAM
用RTL为LSU编写一个SRAM模块, 地址位宽为32bit, 数据位宽为32bit; 收到读写请求后, 通过DPI-C调用`dpic_pmem_read()`/`dpic_pmem_write()`, 并延迟1周期返回读出的数据. 此时可以保留`dpic_pmem_read()`/`dpic_pmem_write()`中的设备访问功能. 实现后, 对于load指令, NPC需要3个周期才能完成:
- 在第1个周期, IFU发出取指请求
- 在第2个周期, IFU拿到指令, 并交给后续的模块译码, 发现是load指令后, 则通过LSU发出访存请求
- 在第3个周期, LSU拿到数据, 并交给WBU写回寄存器

具体实现上:
- 通过加一级流水线寄存器实现1周期的延迟, 并增加级间握手
- 第三个周期lsu交给wb写回数据时一同给出更新 pc 的 valid 信号
- 弱化了 difftest 条件, 为了方便不检查 pc 是否对应了
- 见 tag: 3-cycle-npc

### 更普遍的存储器 & 错误处理和异常
事实上, 读延迟为1周期的特性通常只有SRAM能够满足, 因为它能够使用与处理器制造相同的工艺进行生产, 但SRAM的价格十分昂贵. 为了实现更低成本的存储器, 通常会采用其他存储密度更大的工艺来制造存储器, 例如DRAM. 但由于电气特性, 这些存储器的读延迟通常大于处理器的1周期

这时处理器不能一直发送读请求, 否则由于处理器的请求速率大于存储器的服务速率, 导致存储器会一直被无用的请求占据, 严重降低整个系统的工作效率. 为了解决这个问题, master需要告诉slave何时发送有效的请求, 同时也需要识别slave何时能接收请求. 这可以通过之前介绍的握手实现: 只要在master和slave之间的读协议添加一对握手信号即可, 也即, 添加rvalid指示处理器发送的读请求raddr有效, 添加rready指示存储器可以接收读请求. 这里的rvalid实际上也充当了读使能ren的作用

事实上, 存储器何时完成读操作也是无法提前得知的, 例如DRAM会周期性地对存储单元的电容进行充电刷新, 如果此时收到读请求, 将会在充电刷新结束之后才会真正读出数据. 另一方面, 处理器也可能因为上一次读出的数据还没用完, 而没有准备好接收存储器返回的数据. 这些问题也都需要通过握手信号来解决: 添加rvalid信号表示存储器已经读出有效的数据, 添加rready信号表示处理器可以接收存储器返回的数据. 不过这两个信号和上文读请求的握手信号重名了, 为了区分, 我们为读地址相关的握手信号添加前缀a表示地址, 即arvalid和arready

因此, 在一次读事务的完成过程中, master和slave都需要经历两次握手: master先等arready, 确保slave接收读地址后, 再等rvalid接收读数据; 而slave则先等arvalid接收读地址, 再等rready, 确保master接收读数据. 当然, 在RTL实现层面, 这些都是状态机.

同样地, 写事务也需要握手, 因此需要添加wvalid和wready信号

**握手信号的微结构设计意义 - 解耦**

存储器处理读写事务的时候可能会发生错误, 例如读写地址超过了存储区间的范围, 或者通过校验码发现读写的存储单元发生损坏. 在这些情况下, slave通常应该告诉master发生了错误, 让master决定如何处理. 因此, 我们需要在存储器返回读出数据时额外传输一个rresp信号, 来指示读操作是否成功, 若不成功, 读数据rdata是无效的. 同理, 存储器在处理写操作后也需要返回一个写回复信号bresp(这里的b表示backward), 当然, 这个信号也需要握手

在处理器中, 如果读写操作出错, 可以进一步抛出异常, 通知软件进行处理. 例如, RISC-V设置了3种Access Fault异常, 分别代表在存储器中取指令, 读数据, 写数据时出错. 这样, 存储器内部的错误就可以通过总线协议传递到处理器, 再通过处理器的异常处理机制告知软件了

此时信号如下所示:

```
+-----+ araddr[log2(N)-1:0] ---> +-----+
|     | arvalid             ---> |     |
|     | <---             arready |     |
|     | <---         rdata[31:0] |     |
|     | <---          rresp[1:0] |     |
|     | <---              rvalid |     |
|     | rready              ---> |     |
| CPU | waddr[log2(N)-1:0]  ---> | MEM |
|     | wdata[31:0]         ---> |     |
|     | wmask[3:0]          ---> |     |
|     | wvalid              ---> |     |
|     | <---              wready |     |
|     | <---          bresp[1:0] |     |
|     | <---              bvalid |     |
+-----+ bready              ---> +-----+
```

## 业界中广泛使用的总线 - AXI协议家族
对上文的总线协议稍作变换:
1. 将写地址和写数据分开, 写地址采用aw前缀, 写数据采用w前缀
2. 将wmask改名为wstrb, 并将信号按功能分成5组

```
araddr  --->               araddr  --->              araddr  ---> -+
arvalid --->               arvalid --->              arvalid --->  AR
<--- arready               <--- arready              <--- arready -+
<--- rdata                 <--- rdata
<--- rresp                 <--- rresp                <--- rdata   -+
<--- rvalid                <--- rvalid               <--- rresp    |
rready  --->       1       rready  --->      2       <--- rvalid   R
waddr   --->      ===>     awaddr  --->     ===>     rready  ---> -+
wdata   --->               awvalid ---> *
wmask   --->               <--- awready *            awaddr  ---> -+
wvalid  --->               wdata   --->              awvalid --->  AW
<--- wready                wmask   --->              <--- awready -+
<--- bresp                 wvalid  --->
<--- bvalid                <--- wready               wdata   ---> -+
bready  --->               <--- bresp                wstrb   --->  |
                           <--- bvalid               wvalid  --->  W
                           bready  --->              <--- wready  -+

                                                     <--- bresp   -+
                                                     <--- bvalid   B
                                                     bready  ---> -+
```

这样就得到了AMBA AXI手册中的的AXI-Lite总线规范了! AXI-Lite有5个事务通道, 分别是读地址(AR), 读数据(R), 写地址(AW), 写数据(W)和写回复(B), 它们的工作状态只取决与各自的握手信号, 因此它们可以独立工作, 例如读请求和写请求可以在同一个周期中同时发送

### 避免握手的死锁和活锁
为了避免dead lock和live lock, AXI标准规范对握手信号的行为添加了一些约束. RTFM, 整理于 [axi.md](./axi.md)

### 让NPC支持AXI-Lite
- 将IFU和LSU的访存接口改造成AXI-Lite
- 将IFU和LSU访问的SRAM模块用AXI-Lite进行封装, 但内部还是通过DPI-C来读写数据; 虽然目前SRAM模块的访问延迟还是固定的1周期, 但需要在master和slave两端都正确地用握手来实现AXI-Lite总线协议
- 由于IFU只会对存储器进行读操作, 不会写入存储器, 因此可以将IFU的AW, W和B三个通道的握手信号均置为0. 更好的做法是在握手信号的另一端通过`assert()`确保它们一直为0
- 为了更好的时序, axi的输入输出都进行了打拍, 因此在只修改了ifu后一条指令最快需要4个周期
- 自己写了支持AXI-Lite的 data sram 和 inst sram, 在内部使用状态机实现交互

### 测试总线的实现
在SRAM模块中添加随机延迟的功能, 来测试总线实现是否能在任意延迟下正确工作: 
- 在SRAM模块中添加一个LFSR, 通过它来决定当前请求的延迟: 添加了 3-bit 的 lfsr

### 总线的仲裁
经过上述改动, 实例化了两个SRAM模块. 但在真实的硬件中, 这两个SRAM模块应该都对应到同一个存储器, 这一点目前是通过`dpic_pmem_read()`/`dpic_pmem_write()`访问仿真环境中唯一的存储器来实现的. 但在真实的硬件中不存在`dpic_pmem_read()`/`dpic_pmem_write()`这样的仿真环境功能, 因此需要考虑如何在硬件实现上让IFU和LSU访问同一个存储器.

这其实是一个多master的问题, 既然slave同时只能接收一个请求, 那就通过一个仲裁器(Arbiter)来决策: 当多个master同时访问同一个slave时, 获得访问权的master将得到放行, 可以成功访问slave; 其他master的请求将阻塞在仲裁器, 等待获得访问权的master访问结束后, 它们才能获得接下来的访问权. 仲裁器需要实现如下功能:

- 调度: 选择一个正在发送有效请求的master
- 阻塞: 阻塞其他master的访问
- 转发: 将获得访问权的master的请求转发给slave, 并在slave的请求到达时, 将其转发给之前的master

多个master同时访问时具体如何选择, 其实是一个调度策略的问题. 在复杂系统中, 调度策略还需要考虑更多问题: 首先要避免饥饿, 即任一个master都能在有限次仲裁后获得访问权; 其次还要避免死锁, 即仲裁器造成的阻塞不应使整个系统出现循环等待的现象. 不过目前NPC是一个多周期处理器, IFU和LSU的master不会同时发送请求, 因此也不必考虑复杂的调度策略, 选择任意简单的调度策略即可: 具体实现上:

- 把访存接口引出到处理器顶层, 分离核内与外设
- 新的顶层 `soc_top.sv` 中, 例化了处理器核心 xcore, sram 和仲裁器 arbiter
- 顶层模块使用了 emacs 提供的 verilog-mode 自动连线
- 以写操作为例, 现在需要以下步骤:
    - 周期1-2: 发送写请求, 写地址与写数据 / 如果总线使用权不在当前 master, 需要额外的一周期来仲裁, 重新分配总线使用权
    - 周期1/2-n: lfsr实现的写延迟, 第n周期成功写入
    - 周期n+1: bvalid 拉高, 允许后级握手
    - 因此一次写操作至少3周期

### 评估NPC的主频和程序性能
实现了AXI-Lite之后, NPC就可以外接实际的SRAM了, 我们将要评估的对象是带有一个AXI-Lite接口的NPC, 其中包含刚才实现的AXI-Lite仲裁器, 而通过DPI-C实现的AXI-Lite接口的SRAM模块则不在评估范围内

- 使用 `find ./ -type f | tr '\n' ' '` 快速列出所有文件
- 命令: `make sta DESIGN=soc_top SDC_FILE=axi-lite-soc/gcd.sdc RTL_FILES="./axi-lite-soc/inc/defines.svh ./axi-lite-soc/bus/arbiter.sv ./axi-lite-soc/core/fetch.sv ./axi-lite-soc/core/lsu.sv ./axi-lite-soc/core/pc_reg.sv ./axi-lite-soc/core/regfile.sv ./axi-lite-soc/core/lsu_wb_pipe.sv ./axi-lite-soc/core/fetch_id_pipe.sv ./axi-lite-soc/core/csr_regs.sv ./axi-lite-soc/core/alu.sv ./axi-lite-soc/core/id.sv ./axi-lite-soc/core/xcore.sv ./axi-lite-soc/core/ex.sv ./axi-lite-soc/core/wb.sv ./axi-lite-soc/soc_top.sv" CLK_FREQ_MHZ=50`
- 综合出的主频为366.069MHz; 面积为26380.816
- 面积大幅减小, 主要是少了例化的ram, 约减少了8w多; 时序差了一点, 猜测可能是综合单周期的时候部分组合逻辑被优化了(?)

### 多个设备的系统
到目前为止系统中还只有存储器. 显然, 真实的计算机系统中并不仅仅只有存储器, 还有其他设备. 因此需要考虑, 如何让NPC访问其他设备: 通过内存映射I/O可以指示CPU访问的设备. 之前在仿真环境中通过`dpic_pmem_read()`和`dpic_pmem_write()`, 按照访存地址来选择需要访问的设备, 从而实现内存映射I/O的功能

实际上, 硬件是通过crossbar（有时也写作Xbar）模块来实现内存映射I/O. Xbar是一个总线的多路开关模块, 可以根据输入端的总线请求的地址, 将请求转发到不同的输出端, 从而传递给不同的下游模块. 这些下游模块可能是设备, 也可能是另一个Xbar. 例如, 下图中的Arbiter用于从IFU和LSU中选择一个请求转发给下游, 下游的Xbar收到请求后, 根据请求中的地址将其转发给下游设备

```
+-----+      +---------+      +------+      +-----+
|FETCH| ---> |         |      |      | ---> | UART|  [0x1000_0000, 0x1000_0fff)
+-----+      |         |      |      |      +-----+
             | Arbiter | ---> | Xbar |
+-----+      |         |      |      |      +-----+
| LSU | ---> |         |      |      | ---> | SRAM|  [0x8000_0000, 0x80ff_ffff)
+-----+      +---------+      +------+      +-----+
```

如果请求的地址位于串口设备UART的地址空间范围, 那么Xbar会将请求转发给UART; 如果请求的地址位于SRAM的地址空间范围, 则将请求转发给SRAM. 如果Xbar发现请求的地址不属于任何一个下游的地址空间, 例如0x0400_0000, 就会通过AXI-Lite的resp信号返回一个错误decerr, 表示地址译码错. 这里的“地址译码”表示将请求的地址转换为下游总线通道的编号, 而Xbar中的地址译码器可以看作是内存映射I/O在硬件实现中的核心模块.

Arbiter和Xbar也可以合并成一个多进多出的Xbar, 视场合也称为Interconnect或总线桥. 例如一个2输入2输出的Xbar. 它可以连接多个master和多个slave, 首先通过Arbiter记录当前请求来自哪个master, 再依据该请求的地址决定将其转发给哪个slave, 如下所示:

```
+-----+      +------+      +-----+
|FETCH| ---> |      | ---> | UART|  [0x1000_0000, 0x1000_0fff)
+-----+      |      |      +-----+
             | Xbar |
+-----+      |      |      +-----+
| LSU | ---> |      | ---> | SRAM|  [0x8000_0000, 0x80ff_ffff)
+-----+      +------+      +-----+
```

### 实现AXI-Lite接口的UART功能
编写一个AXI-Lite接口的slave模块, 其中包含一个设备寄存器. 当往这个设备寄存器发送写请求时, 则将写入数据的低8位作为字符, 通过`$write()`或`printf()`输出. 为了方便测试, 这个设备寄存器的地址可以设置成与之前仿真环境中串口的地址相同. 实现后, 你还需要自己编写一个Xbar模块, 来将这个具备UART功能的模块接入系统中.

事实上, 我们并没有完整地用RTL来实现一个UART, 因为$write()或printf()仍然需要依赖仿真环境来实现字符的输出. 但作为一个总线的练习, 这已经足够了, 毕竟UART的实现还需要考虑很多电气细节. 不过我们很快就会接入SoC, 其中包含一个真实的UART控制器. 现在通过这个练习来测试总线的实现, 将来接入SoC的时候也会更顺利.