# 总线
目前已经设计了单周期处理器NPC, 也了解了设备如何工作. 不过之前是让仿真环境来提供设备的功能, 现在需要从硬件上实现NPC与其他设备通信的功能

计算机中每个模块并非独立工作, 不同的模块之间需要进行数据交换: CPU和内存控制器之间, 内存控制器和内存颗粒之间, 取指单元和译码单元之间等等,都需要通过一套约定的协议进行通信. 软件同样如此, 在我们使用的DiffTest中, NEMU需要与Spike通信, NPC也需要与NEMU通信才能实现相应的功能

从广义上来说, 总线其实就是一个通信系统, 用来在不同的模块之间进行数据传输. 狭义的总线即硬件模块间的通信协议

## 常见的总线模型
一般称主动发起通信的模块为master(主设备), 称响应通信的模块为slave(从设备)

### 最简单的总线(例如单周期处理器的IFU与IDU之间的通信)
- 每个周期master都向slave发送有效信息
- master一旦发送有效信息, slave能够立刻收到

### 异步总线
- 只有在valid信号有效时才认为信息有效
- master发送的信息, 只有在ready信号有效时才认为slave收到

valid和ready均有效, 也称为"握手", 表示master和slave对信息的成功传递达成共识

#### 状态机描述异步总线

```
 +-+ valid = 0
   | v         valid = 1
1. idle ----------------> 2. wait_ready <-+
   ^                          |      |    | ready = 0
   +--------------------------+      +----+
              ready = 1
```

一开始处于空闲状态idle, 将valid置为无效
- 如果不需要发送消息, 则一直处于idle状态
- 如果需要发送消息, 则将valid置为有效, 并进入wait_ready状态, 等待slave就绪
在wait_ready状态中, 同时检测slave的ready信号
- 如果ready信号有效, 则握手成功, 返回idle状态
- 如果ready信号无效, 则继续处于wait_ready状态等待

## 总线视角下的处理器设计
- 对于单周期处理器, 相当于每个周期上游发送的消息都有效, 同时下游处于就绪状态来接收新消息
- 对于多周期处理器, 上游模块空闲时消息无效, 下游模块忙碌时不接收新消息; IFU收到WBU的完成信号后再取下一条指令
- 对于流水线处理器, 则可以让IFU一直取指, 同时每个模块只要有消息处理完成, 就在每个周期都尝试向下游发送消息
- 对于乱序执行处理器, 则可以看成在流水线的基础上进行很小的扩展: 每一个下游模块中都有一个队列, 上游模块只需把消息发送到队列中, 就可以不用关心下游队列的状态继续工作

采取分布式的控制策略:
- 模块可以独立工作: 每个模块的行为只取决于自身和下游模块的状态(例如在乱序执行处理器中, 上游模块可以一直工作, 直到下游模块中的队列满为止)
- 具有更好的可扩展性: 在分布式控制中, 能够非常容易插入一个新模块, 只需要修改该模块的上下游模块的接口实现即可
- 采用这种基于握手的分布式控制, 可以统一不同微结构的处理器的设计. 乱序执行处理器天生就是分布式控制的, 这是因为乱序执行处理器中的模块和每个模块的状态都非常多, 且随时可能到来一些不同的事件(如中断到来, 流水线阻塞等), 如果采用集中式控制, 几乎无法保证控制器能在每个模块发生不同事件时都做出正确的决策