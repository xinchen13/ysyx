# 加法器与ALU
加法是数字系统中最常执行的运算，加法器是 ALU(算术逻辑部件 Arithmetic-Logic Unit) 的核心部件

## 加法器
**一位全加器**: 一位全加器由输入 a, b，进位 c_i，输出 s 以及输出进位 c_o 组成. 将一位全加器串联就能够构成简单的加法器，但是由于进位需要串行计算，效率较低. 在 Verilog 语言中，可以使用算术赋值语句和向量来执行这种算术运算. 如下(该代码定义了可以生成n位加法器的电路，但是该加法器电路并不包含加法过程中产生的进位输出信号和算术溢出信号)

```verilog
input  [n-1:0]  in_x, in_y;
output [n-1:0]  out_s;
...
out_s = in_x + in_y;
```

对于进位信号可以用下面的表达式得到

```verilog
{out_c,out_s} = in_x + in_y;
```

如果要判断有符号数加法的溢出，可以利用表达式: $Overflow = (in\_x[n-1] == in\_y[n-1])$ && $(out\_s[n-1] != in\_x[n-1])$ 

如果两个参加加法运算的变量符号相同，而运算结果的符号与其不相同，则运算结果不准确，产生溢出，即两个正数相加结果为负数，或者两个负数相加结果为正数，则发生了溢出. 一正一负两个数相加是不会产生溢出的

## ALU
**ALU 设计**: RISC-V 基础指令集 RV32I 只支持 32 位整型数值的操作. 操作数可以是带符号补码整数或无符号数. ALU 不需要完成乘除法，不需要进行溢出判断，相关操作由软件来完成. RV32I 的 ALU 需要完成以下操作

- 加减法: 完成带符号补码数和无符号数的加减法操作，无需判断溢出和进位，此条件下，可以统一处理带符号数和无符号数
- 逻辑运算: 完成 XOR, AND 及 OR 操作，其他操作采用软件实现
- 移位运算: 完成逻辑左移, 逻辑右移, 算术右移等功能
- 比较运算: 完成带符号数与无符号数的全等和大小比较.此类运算均可利用减法实现
  - 全等可以用减法 Zero 判断
  - 带符号数的大小比较，可以用减法比较，即比较 A, B 两数大小时，首先 B 取反加一，然后与 A 相加. 在不溢出时，结果的符号位为 1 则 A 小于 B. 如果减法溢出，则 A 和 B 原始符号一定不同. 此时，如果结果符号位为 0，说明 A 为负数，B 为正数，B 取反加一后为负，两者相加为正，所以 A 应小于 B. 在溢出时如果结果符号位为 1，则 B 小于等于 A. 所以，可以用 $Less = out[n-1]\ \  xor\ \ Overflow$ 判断


## 实验: 实现一个带有逻辑运算的简单 ALU
ALU 进行加减运算时，需要能够判断结果是否为 0，是否溢出，是否有进位等. 这里，输入的操作数 A 和 B 都已经是补码. 比较大小按带符号数的方式设置. 执行逻辑操作时不需要考虑溢出. 功能表如下所示

<img src="../../../figs/Screenshot from 2024-04-09 11-48-23.png" width="450" />

- Verilog 文件 [top.v](./vsrc/top.v)
- C++ wrapper [sim_main.cpp](./csrc/sim_main.cpp)
- [Makefile](./Makefile)
- 管脚[top.ndxc](./constr/top.nxdc). 

逻辑都比较简单，主要的问题在于溢出检测:
- 加法: 如果 a, b 符号位一致，且与加和结果的符号位不同，则为溢出
- 减法: 如果 a, b 符号位不同，且减法结果的符号位与 a 不同，则为溢出