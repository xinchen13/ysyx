# 异常处理和RT-Thread
实现IOE后, 接下来在nemu和npc上实现CTE, 就可以运行不简单的操作系统了

## 在NEMU中实现自陷操作(pa3阶段1)
### 批处理系统
要有一个后台程序(操作系统), 当一个前台程序执行结束的时候, 后台程序就会自动加载一个新的前台程序来执行

程序之间的执行流切换不用jal: 希望保护操作系统, 当用户程序崩溃时操作系统依然正常工作

#### 什么是操作系统(二周目回答)?

特权模式: 以支持现代操作系统的RISC-V处理器为例, 它们存在M, S, U三个特权模式, 分别代表机器模式, 监管者模式和用户模式. M模式特权级最高, U模式特权级最低. 通常来说, 操作系统运行在S模式, 因此有权限访问所有的代码和数据; 而一般的程序运行在U模式, 这就决定了它只能访问U模式的代码和数据. 这样, 只要操作系统将其私有代码和数据放S模式中, 恶意程序就永远没有办法访问到它们. 为了简化，NEMU中加让所有用户进程都运行在最高特权级

### 自陷指令
中断/异常响应机制(ISA规范): 一种可以限制入口的执行流切换方. 程序执行自陷指令之后, 就会陷入到操作系统预先设置好的跳转目标, 这个跳转目标也称为异常入口地址

### riscv32异常响应机制
riscv32提供`ecall`指令作为自陷指令. 为了保存程序当前的状态, 需要一些特殊的系统寄存器(控制状态寄存器, CSR寄存器). 在PA中, 我们用到了4个CSR寄存器:

- `mtvec`寄存器: 存放异常入口地址
- `mepc`寄存器: 存放触发异常的PC
- `mstatus`寄存器: 存放处理器的状态
- `mcause`寄存器: 存放触发异常的原因

riscv32触发异常后硬件的响应过程如下:

1. 将当前PC值保存到mepc寄存器
2. 在mcause寄存器中设置异常号
3. 从mtvec寄存器中取出异常入口地址
4. 跳转到异常入口地址

由于异常入口地址是硬件和操作系统约定好的, 接下来的处理过程将会由操作系统来接管, 操作系统将视情况决定是否终止当前程序的运行(例如触发段错误的程序将会被杀死). 若决定无需杀死当前程序, 等到异常处理结束之后, 就根据之前保存的信息恢复程序的状态, 并从异常处理过程中返回到程序触发异常之前的状态

riscv32通过`mret`指令从异常处理过程中返回, 它将根据mepc寄存器恢复PC

### 将上下文管理抽象成CTE
与IOE一样, 上下文管理的具体实现也是架构相关的: 例如x86/mips32/riscv32中分别通过int/syscall/ecall指令来进行自陷, 可以将上下文管理的功能划入到AM的一类新的API中, 名字叫CTE(ConText Extension)

考虑需要的api, 操作系统需要用到的信息有:
- 引发这次执行流切换的原因, 是程序除0, 非法指令, 还是触发断点, 又或者是程序自愿陷入操作系统? 根据不同的原因, 操作系统都会进行不同的处理
- 程序的上下文了, 在处理过程中, 操作系统可能会读出上下文中的一些寄存器, 根据它们的信息来进行进一步的处理. 例如操作系统读出PC所指向的非法指令, 看看其是否能被模拟执行. 事实上, 通过这些上下文, 操作系统还能实现一些神奇的功能, 在PA4中了解更详细的信息

抽象CTE api所需要的信息: 
- 引发执行流切换的原因: `$AM_HOME/am/include/am.h`中定义了Event, 让每个架构在实现各自的CTE API时, 都统一通过上述结构体来描述执行流切换的原因, 就可以实现切换原因的抽象了
- 程序的上下文: `$AM_HOME/am/include/arch/riscv.h`中定义了Context

两个统一的API:

- `bool cte_init(Context* (*handler)(Event ev, Context *ctx))`: 用于进行CTE相关的初始化操作. 其中它还接受一个来自操作系统的事件处理回调函数的指针, 当发生事件时, CTE将会把事件和相关的上下文作为参数, 来调用这个回调函数, 交由操作系统进行后续处理
- `void yield()` 用于进行自陷操作, 会触发一个编号为EVENT_YIELD事件. 不同的ISA会使用不同的自陷指令来触发自陷操作

## 在NEMU中运行RT-Thread
根据PA讲义完成PA4阶段1, 直到启动RT-Thread. 后续Nanos-lite相关的内容暂时不管