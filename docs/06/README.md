# 完成PA1
南京大学『计算机系统基础』课程实验PA是国内首个也是目前唯一一个模拟器教学实验

- PA承担了系统能力培养的绝大部分任务: 从硬件模拟器, ISA, 运行时环境, 到自制OS, 库函数, 应用程序, 可以深刻认识到程序如何在计算机上运行的每一处细节
- 模拟器是处理器测试验证的一个重要组件: 我们希望大家可以理解模拟器中的每一处细节, 需要的时候可以自行对它进行定制, 而不是把它当作一个和自己没有关系的外部工具

## 阅读PA讲义中的FAQ
- `PA` 是 `Programming Assignment`
- PA 通过 C 语言开发一款模拟器以及上层的软件(裸机运行时环境, 简易操作系统等)，更关注抽象层次的认识和理解

## 准备工作
进入『一生一芯』工作目录，开 pa1 新分支 `git checkout -b pa1`

初始化 am-kernels: `bash init.sh am-kernels`

### NEMU是什么
NEMU模拟了一个计算机系统，并基于此运行程序

我们可以把计算机看成由若干个硬件部件组成, 这些部件之间相互协助, 完成"运行程序"这件事情. 在NEMU中, 每一个硬件部件都由一个程序相关的数据对象来模拟, 例如变量, 数组, 结构体等; 而对这些部件的操作则通过对相应数据对象的操作来模拟. 例如NEMU中使用数组来模拟内存, 那么对这个数组进行读写则相当于对内存进行读写

### 选择ISA 
ISA是软件和硬件之间的接口——本质就是规范, ISA的存在形式既不是硬件电路, 也不是软件代码, 而是一本规范手册

NEMU的框架代码会把`riscv32`作为默认的ISA, 如果希望选择其它ISA, 需要在NEMU的工程目录下执行 `make menuconfig`, 然后在Base ISA一栏中切换, 然后保存配置并退出菜单, 根据『一生一芯』项目的要求，选择默认的`riscv32`

### 最简单的计算机
由存放程序的存储器，进行运算的CPU等组成. 为了控制CPU进行数据处理，我们可以通过指令来控制; 进而能否让程序来自动控制计算机的执行? 为了实现这个设想, 约定: 当执行完一条指令之后, 就继续执行下一条指令. 有一个特殊的计数器叫`PC(Program Counter)`, 因此，可以简单地认为CPU只做一件事：

```c
while(1){
    从 PC 指示的存储器取出指令;
    执行指令;
    更新 PC;
}
```

我们只要将一段指令序列放置在存储器中, 然后让PC指向第一条指令, 计算机就会自动执行这一段指令序列, 永不停止

### 计算机可以没有寄存器吗, 对编程模型有什么影响
可以，加入寄存器只是提高访问数据的速度; 没有寄存器就直接从内存存取数据，不需要 load/store 操作了

GPT-3.5-Turbo:
```
可能性：理论上，一些极端简化的计算模型可以在没有寄存器的情况下运行，比如图灵机等。这些模型可能通过其他方式来存储和操作数据，但这种情况下的计算机将是极为简化和低效的。
对硬件提供的编程模型的影响：
数据存储和访问：没有寄存器意味着没有快速的内部存储器来存储指令、数据和中间结果。这将导致计算机需要频繁地访问外部存储器，降低了计算机的性能。
指令执行：缺乏寄存器会使得指令的操作数需要从缓慢的内存中读取，导致指令执行速度大幅下降。
编程模型：缺少寄存器将对编程模型产生深远影响，可能需要重新设计指令集架构、编程语言和编程范式，以适应这种新的硬件限制。
```

### 尝试理解计算机如何计算
将高级的编程语言翻译为对应的指令顺序存储在存储器内，然后根据PC指向调用硬件执行对应指令(核心思想是存储程序，即图灵机)

图灵机(Turing Machine, TRM)，最简单的真实计算机需要:
- 结构上, TRM有存储器, 有PC, 有寄存器, 有加法器
- 工作方式上, TRM不断地重复以下过程: 从PC指示的存储器位置取出指令, 执行指令, 然后更新PC

### 状态机模型: 从状态机视角理解程序运行
计算机是个状态机: pc, regs, mem

程序是个状态机: 给定一个程序, 把它放到计算机的内存中, 就相当于在状态数量为N的状态转移图中指定了一个初始状态, 程序运行的过程就是从这个初始状态开始, 每执行完一条指令, 就会进行一次确定的状态转移

下面的指令序列可以计算`1+2+...+100`, 其中`r1`和`r2`是两个寄存器, 还有一个隐含的程序计数器`PC`, 它的初值是`0`. 计算机执行以上的指令序列, 最后会在PC=5处的指令陷入死循环, 此时计算已经结束, `1+2+...+100`的结果会存放在寄存器`r1`中

```
// PC: instruction    | // label: statement
0: mov  r1, 0         |  pc0: r1 = 0;
1: mov  r2, 0         |  pc1: r2 = 0;
2: addi r2, r2, 1     |  pc2: r2 = r2 + 1;
3: add  r1, r1, r2    |  pc3: r1 = r1 + r2;
4: blt  r2, 100, 2    |  pc4: if (r2 < 100) goto pc2;   // branch if less than
5: jmp 5              |  pc5: goto pc5;
```

我们用一个三元组`(PC, r1, r2)`就可以表示程序的所有状态, 而无需画出内存的具体状态. 初始状态是`(0, x, x)`, 此处的`x`表示未初始化. 程序 PC=0 处的指令是`mov r1, 0`, 执行完之后PC会指向下一条指令, 因此下一个状态是`(1, 0, x)`. 如此类推, 我们可以画出执行指令的状态转移过程(程序中的循环只画出前两次循环和最后两次循环):

```
(0, x, x) -> (1, 0, x) -> (2, 0, 0) -> (3, 0, 1) -> (4, 1, 1) -> (2, 1, 1) -> (3, 1, 2) -> (4, 3, 2) -> (2, 3, 2) -> (3, 3, 3) -> (4, 6, 3) -> ... -> (4, 1+2+...+98, 98) -> (2, 1+2+...+98, 98) -> (3, 1+2+...+98, 99) -> (4, 1+2+...+98+99, 99) -> (2, 1+2+...+98+99, 99) -> (3, 1+2+...+98+99, 100) -> (4, 1+2+...+98+99+100, 100) -> (5, 1+2+...+98+99+100, 100) -> ...
```

## RTFSC: NEMU
在NEMU中模拟的计算机称为"客户(guest)计算机", 在NEMU中运行的程序称为"客户程序"

NEMU主要由4个模块构成: monitor, CPU, memory, 设备

在`nemu/`目录下编译并运行nemu: `make run`,之后出现报错信息:

```sh
Welcome to riscv32-NEMU!
For help, type "help"
[src/monitor/monitor.c:35 welcome] Exercise: Please remove me in the source code and compile NEMU again.
riscv32-nemu-interpreter: src/monitor/monitor.c:36: welcome: Assertion `0' failed.
make: *** [/home/xinchen/ysyx/nemu/scripts/native.mk:38: run] Aborted (core dumped)
```

进入`src/monitor/monitor.c`, 将错误提示显示的welcome函数中如下语句注释，重新编译运行错误信息消失

```c
  // Log("Exercise: Please remove me in the source code and compile NEMU again.");
  // assert(0);
```

### 究竟要执行多久
在`cmd_c()`函数中, 调用`cpu_exec()`的时候传入了参数`-1`:

`-1`保存在存储器中的二进制位全为1,但注意到`cpu_exec()`接收参数的数据类型为`uint64_t`，也就是说传入的数据被C语言解释为最大的正数, 即执行最多数量的指令

### 为NEMU编译时添加GDB调试信息
在menuconfig中打开对应选项, 清除编译结果并重新编译

```sh
Build Options
  [*] Enable debug information
```

开启调试选项后查看 `nemu/include/auto.conf` 生成的宏，发现有`CONFIG_CC_DEBUG=y`, 在Makefile中有语句`CFLAGS_BUILD += $(if $(CONFIG_CC_DEBUG),-Og -ggdb3,)`即编译时加入了调试选项

### 优美地退出
修复运行NEMU之后直接键入`q`退出产生的报错: 利用gdb来对NEMU进行调试，运行`make gdb`

发现`engine_start()`函数结束后返回`nemu/src/utils/state.c`中的`is_exit_status_bad()`. 根据其要求，发现返回值为`-1`. 查看代码，是利用nemu_state来判定返回值. 其中判断语句为:

```c
int good = (nemu_state.state == NEMU_END && nemu_state.halt_ret == 0) || (nemu_state.state == NEMU_QUIT);
```

因此，只需要将按下`q`时的`nemu_state.state`设置为`NEMU_QUIT`即可，这样就可正常退出程序. 由于NEMU中`c`和`q`分别对应`nemu/src/monitor/sdb/sdb.c`中的`cmd_c()`与`cmd_q()`函数，发现`cmd_c()`函数调用了`cpu_exec()`, 此函数中对`nemu_state`作出了修改. 同理，我们可以直接在`cmd_q()`中添加`nemu_state.state = NEMU_QUIT`, 重新编译运行，测试无误

## 简易调试器
### 单步执行
框架代码中已经给出了模拟CPU执行方式的函数, 即在`nemu/src/cpu/cpu-exec.c`中的`cpu_exec(uint64_t n)`, 基于此，单步执行要求执行N条指令后暂停执行，换句话说就是从命令行读取到N ，就将`cpu_exec()`函数执行N次

- 首先在`cmd_table`中添加`si`命令，然后编写`cmd_si(char *args)`函数完成功能. 从命令行读取命令并获得参数，`cmd_help()`函数中给出了例子，直接按其的框架修改. 
- 利用`strtok()`函数获取参数, 每次提取一个词条: 第一次 call `strtok()` 时需要制定 str, 之后调用 str 指定为 null 
- `sscanf`通常被用来解析并转换字符串，其格式定义灵活多变，可以实现很强大的字符串解析功能: 在这里从字符串读入格式化内容，并解析为`int`类型数字(参数缺省时缺省时默认为1), 给`cpu_exec()`传入

### 打印寄存器
要求执行`info r`之后, 就调用`nemu/src/isa/$ISA/reg.c`目录下的`isa_reg_display()`, 在里面直接通过`printf()`输出所有寄存器的值即可. RTFSC可知，寄存器结构体`CPU_state`的定义放在`nemu/src/isa/$ISA/include/isa-def.h`中, 并在`nemu/src/cpu/cpu-exec.c`中定义一个全局变量`cpu`

- 首先在`cmd_table`中添加`info`命令, 并设置参数`r`. 之后就在`cmd_info(char *args)`函数中利用`strcmp()`进行参数判断与调用`isa_reg_display()`
- 在`isa_reg_display()`中通过`printf()`格式控制输出`pc`和通用寄存器的值 采用api提供的`FMT_WORD`来输出
- 由于ISA为`rv32e`时只有16个寄存器, `riscv32/64`有32个, 因此通用寄存器数量在使用时参考 `nemu/src/isa/$ISA/include/isa-def.h` 中的定义

### 扫描内存
对命令进行解析之后, 先求出表达式的值(还没有实现表达式求值的功能, 可以先实现一个简单的版本: 规定表达式`EXPR`中只能是一个十六进制数), 解析出待扫描内存的起始地址之后, 就可以使用循环将指定长度的内存数据通过十六进制打印出来

与之前类似的做法依次提取参数，并通过`sscanf()`函数来把读取的字符串转化为整形，第一个参数是开始的地址，第二个参数是读取的4字节数; 读取内存利用`vaddr_read(vaddr_t addr, int len)`函数按字节读取(需要增加头文件`#include <memory/vaddr.h>`)

## 表达式求值
### 算术表达式的词法分析
为算术表达式中的各种token类型添加规则，在成功识别出token后, 将token的信息依次记录到`tokens`数组中

词法分析识别出表达式中的token，包含很多复杂场景，如: 十六进制整数`0x80100000`, 小括号, 访问寄存器`$a0`, 指针解引用`*`, 访问变量`number`等. 可以用正则表达式来匹配复杂pattern

在框架代码中, 一条规则是由正则表达式和token类型组成的二元组. 框架代码中已经给出了`+`和空格串的规则, 其中空格串的token类型是`TK_NOTYPE`, 因为空格串并不参加求值过程, 识别出来之后就可以将它们丢弃了; `+`的token类型是`+`. 事实上token类型只是一个整数, 只要保证不同的类型的token被编码成不同的整数就可以了

这些规则会在简易调试器初始化的时候通过`init_regex()`被编译成一些用于进行pattern匹配的内部信息, 这些内部信息是被库函数使用的, 而且它们会被反复使用, 但你不必关心它们如何组织. 但如果正则表达式的编译不通过, NEMU将会触发assertion fail, 此时需要检查编写的规则是否符合正则表达式的语法

给出一个待求值表达式, 我们首先要识别出其中的token, 进行这项工作的是`make_token()`函数. `make_token()`函数的工作方式十分直接, 它用`position`变量来指示当前处理到的位置, 并且按顺序尝试用不同的规则来匹配当前位置的字符串. 当一条规则匹配成功, 并且匹配出的子串正好是`position`所在位置的时候, 我们就成功地识别出一个token, `Log()`宏会输出识别成功的信息. 需要做的是将识别出的token信息记录下来(一个例外是空格串), 我们使用`Token`结构体来记录token的信息

其中`type`成员用于记录token的类型. 大部分token只要记录类型就可以了, 例如`+`, `-`, `*`, `/`, 但这对于有些token类型是不够的: 如果我们只记录了一个十进制整数token的类型, 在进行求值的时候我们还是不知道这个十进制整数是多少. 这时我们应该将token相应的子串也记录下来, `str`成员就是用来做这件事情的. 由于`str`成员的长度是有限的, 在存储对应的`str`字段时进行长度判断，防止缓冲区溢出. `tokens`数组用于按顺序存放已经被识别出的token信息, `nr_token`指示已经被识别出的token数目

如果尝试了所有的规则都无法在当前位置识别出token, 识别将会失败, 框架代码会输出当前token的位置(当表达式过长导致在终端里输出需要换行时, `^`可能无法指示正确的位置, 此时通过输出的`position`值来定位token的位置). 这通常是待求值表达式并不合法造成的,`make_token()`函数将返回`false`, 表示词法分析失败

**接下来在`expr.c`文件中`rules[]`完善算术表达式规则(添加了十进制数字、`+`,`-`,`*`,`/`,`(`,`)`运算符和空格); 并为`make_token()`函数添加对应的操作，通过switch语句把识别到的token保存到`tokens[]`数组中，至此就完成了算术表达式的词法分析**

**在`expr.c`中添加了宏`TOKEN_STR_LEN_MAX`以及`TOKENS_COUNT_MAX`来控制记录的token字符串最大长度与表达式最大长度** 

**在`$NEMU_HOME/Kconfig`添加了调试宏`CONFIG_EXPR_DEBUG_INFO`来控制词法分析中间过程的结果输出, 可以通过`make menuconfig`开关**

### 递归求值
既然长表达式是由短表达式构成的, 就先对短表达式求值, 然后再对长表达式求值. 这种十分自然的解决方案就是分治法的应用, 可以使用递归实现

一个问题是, 给出一个最左边和最右边不同时是括号的长表达式, 我们要怎么正确地将它分裂成两个子表达式? 我们定义"主运算符"为表达式人工求值时, 最后一步进行运行的运算符, 它指示了表达式的类型(例如当一个表达式的最后一步是减法运算时, 它本质上是一个减法表达式). 要正确地对一个长表达式进行分裂, 就是要找到它的主运算符. 如何在一个token表达式中寻找主运算符:

1. 非运算符的token不是主运算符
2. 出现在一对括号中的token不是主运算符. 注意到这里不会出现有括号包围整个表达式的情况, 因为这种情况已经在`check_parentheses()`相应的if块中被处理了
3. 主运算符的优先级在表达式中是最低的. 这是因为主运算符是最后一步才进行的运算符, `priority()`是设计用于判断运算同一层符优先级的函数
4. 当有多个运算符的优先级都是最低时, 根据结合性, 最后被结合的运算符才是主运算符. 一个例子是 `1 + 2 + 3`, 它的主运算符应该是右边的`+`
5. 要找出主运算符, 只需要将token表达式全部扫描一遍, 就可以按照上述方法唯一确定主运算符

找到了正确的主运算符之后, 先对分裂出来的两个子表达式进行递归求值, 然后再根据主运算符的类型对两个子表达式的值进行运算即可.

需要注意的是, 上述框架中并没有进行错误处理, 在求值过程中发现表达式不合法的时候, 应该给上层函数返回一个表示出错的标识, 告诉上层函数"求值的结果是无效的". 例如在`check_parentheses()`函数中, `(4 + 3)) * ((2 - 1)`和`(4 + 3) * (2 - 1)`这两个表达式虽然都返回false, 因为前一种情况是表达式不合法, 是没有办法成功进行求值的; 而后一种情况是一个合法的表达式, 是可以成功求值的, 只不过它的形式不属于BNF中的`(" <expr> ")`, 需要使用主运算符的方式进行处理, 因此在`check_parentheses()`作出区分, 并且层层传递的`success`变量作为求值是否成功的标识符

### 区分减号和负号
在上述实现中, 并没有考虑负数的问题, 例如`1+-1`和`--1`(我们不实现自减运算, 这里应该解释成`-(-1)=1`)
它们会被判定为不合法的表达式. 为了实现负数的功能, 需要考虑两个问题:

#### 如何区分负号和减号:
`-`符号判定为负号分为以下几种情况:
1. 处于表达式头部
2. 处于`(`后
3. 处于`+`, `-`, `*`, `/`, 负号后

#### 负号是个单目运算符, 分裂的时候需要注意什么:
1. 负号运算具有最高的运算优先级
2. 主要根据表达式前一词条的类型来分离负号与减号
3. 在`eval()`函数中设定负号的运算方式为`0-val2`
4. 规定在选定主运算符时，最先出现的负号为主运算符(右结合性)

最后在`eval()`函数中根据BNF框架实现递归求值

### 表达式求值: 实现表达式生成器
表达式生成器的框架代码在`nemu/tools/gen-expr/gen-expr.c`中. 需要实现其中的`void gen_rand_expr()`函数, 将随机生成的表达式输出到缓冲区buf中. main函数中的代码会调用实现的`gen_rand_expr()`, 然后把buf中的随机表达式放入上述C程序的代码中. 剩下的事情就是编译运行这个C程序了, 代码中使用了`system()`和`popen()`等库函数来实现这一功能. 最后, 框架代码将这个C程序的打印结果和之前随机生成的表达式一同输出, 这样就生成了一组测试用例, 在实现过程中，需要面对一些细节的问题:

#### 如何生成随机数
`uint32_t choose(uint32_t n)`是一个很简单又很重要的函数, 它的作用是生成一个小于n的随机数, 所有随机生成的内容几乎都是通过它来选择的，通过设置seed来确保一定的随机性

#### 如何保证表达式进行无符号运算
在`gen-expr`进行表达式运算的字符串中，把数字的格式改为如`66u`与`-32u`的格式，存储为无符号类型，就能够进行无符号运算

#### 如何随机插入空格
通过`gen_rand_blank()`函数在表达式中随机插入0-2个空格

#### 如何生成长表达式, 同时不会使buf溢出
首先控制生成数字的大小为0-99; 其次通过为表达式生成函数`gen_rand_expr()`传递生成次数，并对其生成次数进行限制，就能够有效限制长表达式长度; 与此同时，修改`expr.c`中tokens数组的大小为1024，以容纳更长的表达式

#### 如何过滤求值过程中有除0行为的表达式
注意到发生除零操作时gcc会给出`waring: division by zero`，因此在编译表达式计算器的时候为gcc加入选项`-Werror`来改变除零时的返回值，从而抛弃该条表达式(同时对于结果溢出的表达式也会一同抛弃)

P.S.:每次生成新的表达式需要对buf进行清零操作，具体为`buf[0] = '\0';`, 否则表达式会向后拼接产生问题

实现后, 就可以用来生成表达式求值的测试用例了. 通过`./gen-expr 10000 > input`生成10000个(由于剔除了除零的表达式，实际数量在9000+个)测试用例到input文件中, 其中每行为一个测试用例, 其格式为`结果 表达式`

再稍微改造一下nemu的`sdb_mainloop()`函数, 让其读入`input`文件中的测试表达式后, 直接调用`expr()`, 并与正确结果进行比较. 为了容纳长表达式的求值, 还需要对tokens数组的大小进行修改，实际操作过程:

- 在`nemu/src/monitor/sdb/sdb.c`中编写了`sdb_debug_expr()`函数，直接调用`expr()`函数验证input文件中的表达式，并将结果写入log
- 在`Kconfig`中添加宏`EXPR_DIFFTEST`作为开关来设置debug模式,在`nemu/src/engine/interpreter/init.c`中通过`MUXDEF`宏来根据`EXPR_DIFFTEST`的值选择执行`sdb_mainloop()`还是`sdb_debug_expr()`
- 若比较结果通过则输出`PASS`,否则中断程序(`assert(0)`)
- 运行测试: `make run > tools/gen-expr/result`

### 功能扩展
之前已经实现了算术表达式的求值, 但这些表达式都是由常数组成的, 它们的值不会发生变化. 这样的表达式在监视点中没有任何意义, 为了发挥监视点的功能, 首先需要扩展表达式求值的功能: 主要包括增加对十六进制数, 寄存器, ==, !=, &&和指针解引用的支持

和GDB中的表达式相比做了简化, 简易调试器中的表达式没有类型之分，所有结果都是`uint32_t`类型

- 首先增加对这些字符串的正则匹配规则, 需要注意十六进制数的匹配要先于十进制数
- 识别到表达式后存储到tokens数组, 需要新增/更新保存规则
    - 在进行递归求值之前, 我们需要将指针解引用(dereference)和乘法区别开来, 否则如果将指针解引用当成乘法来处理的话, 求值过程将会认为表达式不合法. 实际上只要看`*`前一个token的类型, 我们就可以决定这个`*`是乘法还是指针解引用了(与负号的判断方法类似)
    - 寄存器的字符保存时丢弃`$`字符
- 增加的运算符需要在`priority(）`中添加运算优先级
- 注意单目运算符的右结合性(在选定主运算符的时候)
- 符号需要在`eval()`中规定运算
    - 指针没有类型, 进行指针解引用的时候, 我们总是从客户计算机的内存中读出一个`uint32_t`类型的整数
- 数据需要在`eval()`函数中得到值
    - 除了10进制, 还包含了十六进制和寄存器
    - 获取寄存器的值是一个ISA相关的功能. 框架代码已经准备`isa_reg_str2val(const char *s, bool *success)`API(用于返回名字为s的寄存器的值, 并设置success指示是否成功), 在部署过程中，需要将保存的寄存器字符串与pc、通用寄存器名对比，输出对应寄存器的值










