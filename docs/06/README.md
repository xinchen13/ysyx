# 完成PA1
南京大学『计算机系统基础』课程实验PA是国内首个也是目前唯一一个模拟器教学实验

- PA承担了系统能力培养的绝大部分任务: 从硬件模拟器, ISA, 运行时环境, 到自制OS, 库函数, 应用程序, 可以深刻认识到程序如何在计算机上运行的每一处细节
- 模拟器是处理器测试验证的一个重要组件: 我们希望大家可以理解模拟器中的每一处细节, 需要的时候可以自行对它进行定制, 而不是把它当作一个和自己没有关系的外部工具

## 阅读PA讲义中的FAQ
- `PA` 是 `Programming Assignment`
- PA 通过 C 语言开发一款模拟器以及上层的软件(裸机运行时环境, 简易操作系统等)，更关注抽象层次的认识和理解

## 准备工作
进入『一生一芯』工作目录，开 pa1 新分支 `git checkout -b pa1`

初始化 am-kernels: `bash init.sh am-kernels`

### NEMU是什么
NEMU模拟了一个计算机系统，并基于此运行程序

我们可以把计算机看成由若干个硬件部件组成, 这些部件之间相互协助, 完成"运行程序"这件事情. 在NEMU中, 每一个硬件部件都由一个程序相关的数据对象来模拟, 例如变量, 数组, 结构体等; 而对这些部件的操作则通过对相应数据对象的操作来模拟. 例如NEMU中使用数组来模拟内存, 那么对这个数组进行读写则相当于对内存进行读写

### 选择ISA 
ISA是软件和硬件之间的接口——本质就是规范, ISA的存在形式既不是硬件电路, 也不是软件代码, 而是一本规范手册

NEMU的框架代码会把`riscv32`作为默认的ISA, 如果希望选择其它ISA, 需要在NEMU的工程目录下执行 `make menuconfig`, 然后在Base ISA一栏中切换, 然后保存配置并退出菜单, 根据『一生一芯』项目的要求，选择默认的`riscv32`

### 最简单的计算机
由存放程序的存储器，进行运算的CPU等组成. 为了控制CPU进行数据处理，我们可以通过指令来控制; 进而能否让程序来自动控制计算机的执行? 为了实现这个设想, 约定: 当执行完一条指令之后, 就继续执行下一条指令. 有一个特殊的计数器叫`PC(Program Counter)`, 因此，可以简单地认为CPU只做一件事：

```c
while(1){
    从 PC 指示的存储器取出指令;
    执行指令;
    更新 PC;
}
```

我们只要将一段指令序列放置在存储器中, 然后让PC指向第一条指令, 计算机就会自动执行这一段指令序列, 永不停止

### 计算机可以没有寄存器吗, 对编程模型有什么影响
可以，加入寄存器只是提高访问数据的速度; 没有寄存器就直接从内存存取数据，不需要 load/store 操作了

GPT-3.5-Turbo:
```
可能性：理论上，一些极端简化的计算模型可以在没有寄存器的情况下运行，比如图灵机等。这些模型可能通过其他方式来存储和操作数据，但这种情况下的计算机将是极为简化和低效的。
对硬件提供的编程模型的影响：
数据存储和访问：没有寄存器意味着没有快速的内部存储器来存储指令、数据和中间结果。这将导致计算机需要频繁地访问外部存储器，降低了计算机的性能。
指令执行：缺乏寄存器会使得指令的操作数需要从缓慢的内存中读取，导致指令执行速度大幅下降。
编程模型：缺少寄存器将对编程模型产生深远影响，可能需要重新设计指令集架构、编程语言和编程范式，以适应这种新的硬件限制。
```

### 尝试理解计算机如何计算
将高级的编程语言翻译为对应的指令顺序存储在存储器内，然后根据PC指向调用硬件执行对应指令(核心思想是存储程序，即图灵机)

图灵机(Turing Machine, TRM)，最简单的真实计算机需要:
- 结构上, TRM有存储器, 有PC, 有寄存器, 有加法器
- 工作方式上, TRM不断地重复以下过程: 从PC指示的存储器位置取出指令, 执行指令, 然后更新PC

### 状态机模型: 从状态机视角理解程序运行
计算机是个状态机: pc, regs, mem

程序是个状态机: 给定一个程序, 把它放到计算机的内存中, 就相当于在状态数量为N的状态转移图中指定了一个初始状态, 程序运行的过程就是从这个初始状态开始, 每执行完一条指令, 就会进行一次确定的状态转移

下面的指令序列可以计算`1+2+...+100`, 其中`r1`和`r2`是两个寄存器, 还有一个隐含的程序计数器`PC`, 它的初值是`0`. 计算机执行以上的指令序列, 最后会在PC=5处的指令陷入死循环, 此时计算已经结束, `1+2+...+100`的结果会存放在寄存器`r1`中

```
// PC: instruction    | // label: statement
0: mov  r1, 0         |  pc0: r1 = 0;
1: mov  r2, 0         |  pc1: r2 = 0;
2: addi r2, r2, 1     |  pc2: r2 = r2 + 1;
3: add  r1, r1, r2    |  pc3: r1 = r1 + r2;
4: blt  r2, 100, 2    |  pc4: if (r2 < 100) goto pc2;   // branch if less than
5: jmp 5              |  pc5: goto pc5;
```

我们用一个三元组`(PC, r1, r2)`就可以表示程序的所有状态, 而无需画出内存的具体状态. 初始状态是`(0, x, x)`, 此处的`x`表示未初始化. 程序 PC=0 处的指令是`mov r1, 0`, 执行完之后PC会指向下一条指令, 因此下一个状态是`(1, 0, x)`. 如此类推, 我们可以画出执行指令的状态转移过程(程序中的循环只画出前两次循环和最后两次循环):

```
(0, x, x) -> (1, 0, x) -> (2, 0, 0) -> (3, 0, 1) -> (4, 1, 1) -> (2, 1, 1) -> (3, 1, 2) -> (4, 3, 2) -> (2, 3, 2) -> (3, 3, 3) -> (4, 6, 3) -> ... -> (4, 1+2+...+98, 98) -> (2, 1+2+...+98, 98) -> (3, 1+2+...+98, 99) -> (4, 1+2+...+98+99, 99) -> (2, 1+2+...+98+99, 99) -> (3, 1+2+...+98+99, 100) -> (4, 1+2+...+98+99+100, 100) -> (5, 1+2+...+98+99+100, 100) -> ...
```

## RTFSC: NEMU
在NEMU中模拟的计算机称为"客户(guest)计算机", 在NEMU中运行的程序称为"客户程序"

NEMU主要由4个模块构成: monitor, CPU, memory, 设备

在`nemu/`目录下编译并运行nemu: `make run`,之后出现报错信息:

```sh
Welcome to riscv32-NEMU!
For help, type "help"
[src/monitor/monitor.c:35 welcome] Exercise: Please remove me in the source code and compile NEMU again.
riscv32-nemu-interpreter: src/monitor/monitor.c:36: welcome: Assertion `0' failed.
make: *** [/home/xinchen/ysyx/nemu/scripts/native.mk:38: run] Aborted (core dumped)
```

进入`src/monitor/monitor.c`, 将错误提示显示的welcome函数中如下语句注释，重新编译运行错误信息消失

```c
  // Log("Exercise: Please remove me in the source code and compile NEMU again.");
  // assert(0);
```

### 究竟要执行多久
在`cmd_c()`函数中, 调用`cpu_exec()`的时候传入了参数`-1`:

`-1`保存在存储器中的二进制位全为1,但注意到`cpu_exec()`接收参数的数据类型为`uint64_t`，也就是说传入的数据被C语言解释为最大的正数, 即执行最多数量的指令

### 为NEMU编译时添加GDB调试信息
在menuconfig中打开对应选项, 清除编译结果并重新编译

```sh
Build Options
  [*] Enable debug information
```

开启调试选项后查看 `nemu/include/auto.conf` 生成的宏，发现有`CONFIG_CC_DEBUG=y`, 在Makefile中有语句`CFLAGS_BUILD += $(if $(CONFIG_CC_DEBUG),-Og -ggdb3,)`即编译时加入了调试选项

### 优美地退出
修复运行NEMU之后直接键入`q`退出产生的报错: 利用gdb来对NEMU进行调试，运行`make gdb`

发现`engine_start()`函数结束后返回`nemu/src/utils/state.c`中的`is_exit_status_bad()`. 根据其要求，发现返回值为`-1`. 查看代码，是利用nemu_state来判定返回值. 其中判断语句为:

```c
int good = (nemu_state.state == NEMU_END && nemu_state.halt_ret == 0) || (nemu_state.state == NEMU_QUIT);
```

因此，只需要将按下`q`时的`nemu_state.state`设置为`NEMU_QUIT`即可，这样就可正常退出程序. 由于NEMU中`c`和`q`分别对应`nemu/src/monitor/sdb/sdb.c`中的`cmd_c()`与`cmd_q()`函数，发现`cmd_c()`函数调用了`cpu_exec()`, 此函数中对`nemu_state`作出了修改. 同理，我们可以直接在`cmd_q()`中添加`nemu_state.state = NEMU_QUIT`, 重新编译运行，测试无误