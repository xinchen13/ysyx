# Double Linked Lists
## 数据结构
具有特性模型的数据组织方法，这一模型可能设计用于以新的方法处理数据，也可能只是用于将它们更高效地储存在磁盘上

## 构建库
创建一个可用的库，包括:
- 为每个数据结构编写的头文件`.h`
- 为算法编写的实现文件`.c`
- 用于测试它们确保有效的单元测试
- 从头文件自动生成的文档

## 双向链表
单向链表通过指向下一个或上一个元素的节点来工作. “双向”链表持有全部这两个指针，而“单向”链表只持有下一个元素的指针
- 优点: 插入和删除元素的操作快
- 缺点: 遍历它涉及到处理沿途每个单个的指针，搜索、多数排序以及迭代元素慢

首先编写头文件[list.h](../liblcthw/src/lcthw/list.h): `ListNode`是链表节点, `List`是链表

每个`ListNode`都有三个成员:
- 值，它是无类型的指针，存储我们想在链表中放置的东西
- `ListNode *next`指针，它指向另一个储存下一个元素的`ListNode`
- `ListNode *prev`指针，它指向另一个储存上一个元素的`ListNode`
`List`结构只是这些`ListNode`结构的容器，它们互联链接组成链型. 它跟踪链表的`count`，`first`和`last`元素

`LIST_FOREACH`宏来生成迭代代码

基于此，就可以在[list.c](../liblcthw/src/lcthw/list.c)中实现, 并在[list_tests.c](../liblcthw/tests/list_tests.c)中添加测试代码, 测试通过:


## 改进代码
- 使用`LIST_FOREACH`并在循环中调用`free`来使`List_clear_destroy`更高效
- 可以为一些先决条件添加断言，使其部结构`NULL`值作为`List *list`的参数
- 可以添加不变了，来检查列表的内容始终正确，例如`count`永远不会`< 0`，如果`count > 0`，`first`不为`NULL`
- 可以向头文件添加文档，在每个结构、函数和宏之前添加描述其作用的注释

## 附加题
### 研究双向和单向链表，以及什么情况下其中一种优于另一种
- 单向优于双向: 增加删除节点时少一个指针，占用空间小
- 双向优于单向: 需要寻找前驱节点

### 研究双向链表的限制
增加删除节点复杂，多需要分配一个指针存储空间

### 还缺少什么你能想到的操作？比如复制、连接、分割等等，实现这些操作，并且为它们编写单元测试
实现了join, 见[lcthw/](../liblcthw/); 并进行了单元测试, 运行`make valgrind`，无内存泄漏
