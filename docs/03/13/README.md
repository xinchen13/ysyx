# Switch Statement
C 中的 switch 语句实际上是一个“跳转表”, 只能够放置结果为整数的表达式，而不是一些随机的布尔表达式，这些整数用于计算从 swicth 顶部到匹配部分的跳转

本节程序: [ex13.c](./ex13.c), 并编译运行:

```sh
(base) xinchen@sakura:~/ysyx/docs/03/13$ ./ex13 yauienjAEIOUhjay
1: 'A'
2: 'U'
3: 'I'
4: 'E'
5: n is not a vowel
6: j is not a vowel
7: 'A'
8: 'E'
9: 'I'
10: 'O'
11: 'U'
12: h is not a vowel
13: j is not a vowel
14: 'A'
15: 'Y'
```

编译器会标记 swicth 语句的顶端，我们先把它记为地址 `Y`; 接着对 switch 中的表达式求值，产生一个数字. 在上面的例子中，数字为 argv[1] 中字母的原始的 ascii 码; 编译器也会把每个类似 `case 'A'` 的 case 代码块翻译成这个程序中距离语句顶端的地址，所以 `case 'A'` 就在 `Y + 'A'` 处; 接着计算是否 `Y+letter` 位于 switch 语句中，如果距离太远则会将其调整为 `Y+Default`; 一旦计算出了地址，程序就会“跳”到代码的那个位置并继续执行. 这就是一些 case 代码块中有 break 而另外一些没有的原因; 如果输出了 `'a'`，那它就会跳到 `case 'a'`，它里面没有 break 语句，所以它会贯穿执行底下带有代码和 break 的 `case 'A'`; 最后它执行这段代码，执行 break 完全跳出 switch 语句块. 更常见的情况是，gcc 会在空白处单独构建一张跳转表，各个偏移处存放对应的 case 语句的地址. `Y` 不是 switch 语句的起始地址，而是这张表的起始地址. 程序会跳转到 `*(Y + 'A')` 而不是 `Y + 'A'` 处

## 使程序崩溃
将一些带有预料之外的值的变量放入switch中, 见 [ex13v1.c](./ex13v1.c), 默认执行 default 分支

其他问题:

- 忘记写 break，程序就会运行两个或多个代码块，这些都是不想运行的
- 忘记写 default，程序会在静默中忽略所忘记的值

## 附加题
### 编写另一个程序，在字母上做算术运算将它们转换为小写，并且在 switch 中移除所有额外的大写字母
新程序为 [ex13v2.c](./ex13v2.c) 实现了把元音大写字母转换为小写，并丢弃其他大写字母、保留其他符号的功能

### 使用 ','（逗号）在 for 循环中初始化 letter
同样见 [ex13v2.c](./ex13v2.c)

### 使用另一个 for 循环来让它处理你传入的所有命令行参数
在字符串处理循环外再加一层循环，遍历接收到的所有命令行参数，见 [ex13v2.c](./ex13v2.c)

### 将这个 switch 语句转为 if 语句，你更喜欢哪个呢
if

### 在 if 代码块外面写了个 break, 这样会产生什么效果？如果把它移进 if 代码块，会发生什么？自己试着解答它，并证明你是正确的
break 不能直接用于 if, 除非 if 属于循环内部的一个子句; 也就是说运行到 break 语句时，就会跳出当前层的循环，暂停字符处理